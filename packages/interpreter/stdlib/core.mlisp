;; Core standard library functions
;; This module provides fundamental functions and combinators

(defun null. (x) (== x '()))

(defun and. (x y)
  (cond (x (cond (y #t)
    (#t #f)))
    (#t #f)))

(defun not. (x)
  (cond (x #f)
    (#t #t)))

;; Function composition combinator
(defun o (f g) (lambda (x) (f (g x))))

;; List accessor combinators
(define caar (o car car))
(define cadr (o car cdr))
(define caddr (o cadr cdr))
(define cadar (o car (o cdr car)))
(define caddar (o car (o cdr (o cdr car))))

;; esetq takes two parameters: an expression and an environment. It's like our evalexp.
(defun eval. (e env)
 (letrec (
      ; cond works by evaluating each of the conditions in order until it
      ; encounters a truthy one.
      (eval-cond. (lambda (c a)
              ; If we have no more conditions left, there's an error.
          (cond ((null. c) 'error)
                ; If the current condition is true, evaluate that branch.
                ((eval. (caar c) a)  (eval. (cadar c) a))
                ; Otherwise, keep going.
                (#t (eval-cond. (cdr c) a)))))
      ; This is a manually curried form of map. It runs esetq over every
      ; element in a list using the given environment.
      (map-eval. (lambda (exps env)
        (cond ((null. exps) '())
              (#t (cons (eval.  (car exps) env)
                        (map-eval. (cdr exps) env)))))))
    ; There are a lot of cases to consider. This is like our large match expression.
    (cond
      ; If it's a symbol, look it up. This is different from pg's Lisp in
      ; that he *only* has symbols to work with.
      ((sym? e) (lookup. e env))
      ; If it's some other type of atom, just leave it be. Let it
      ; self-evaluate.
      ((atom? e) e)
      ; If it's a list (the only alternative to being an atom), check if the
      ; first item is an atom.
      ((atom? (car e))
      ; What kind of form is it?
       (cond
         ; Quote accepts one argument, so just return that argument as an
         ; unevaluated expression (note the lack of a recursive call to
         ; eval.).
         ((== (car e) 'quote) (cadr e))
          ; For atom?, eq, car, cdr, and cons, just evaluate the expression
          ; then pass it through to the built-in form.
         ((== (car e) 'atom?) (atom? (eval. (cadr e)  env)))
         ((== (car e) 'eq) (== (eval. (cadr e)  env) (eval. (caddr e) env)))
         ((== (car e) 'car)   (car   (eval. (cadr e)  env)))
         ((== (car e) 'cdr)   (cdr   (eval. (cadr e)  env)))
         ((== (car e) 'cons)  (cons  (eval. (cadr e)  env)
                                     (eval. (caddr e) env)))
         ; For cond, it's a wee bit tricker. We get to this function a bit
         ; later.
         ((== (car e) 'cond)  (eval-cond. (cdr e) env))
         ; A bunch of pass-through math operations.
         ((== (car e) '+) (+ (eval. (cadr e) env) (eval. (caddr e) env)))
         ((== (car e) '*) (* (eval. (cadr e) env) (eval. (caddr e) env)))
         ((== (car e) '-) (- (eval. (cadr e) env) (eval. (caddr e) env)))
         ((== (car e) '<) (< (eval. (cadr e) env) (eval. (caddr e) env)))

         ; ...else, try and evaluate the function as a user-defined function,
         ; applying it to the arguments.
         (#t (eval. (cons (lookup. (car e) env) (cdr e)) env))))

      ; If it's a compound expression in which the first element is a
      ; label-expression,
      ((== (caar e) 'label)
        ; ...evaluate the expression in environment with a new recursive
        ; binding.
       (eval. (cons (caddar e) (cdr e)) (cons (list. (cadar e) (car e)) env)))

      ; If it's a compound expression in which the first element is a
      ; lambda-expresison,
      ((== (caar e) 'lambda)
        ; ...evaluate the application of the lambda to the given arguments,
        ; evaluating them.
       (eval. (caddar e) (append. (zip. (cadar e) (map-eval. (cdr e) env)) env))))))

